# OPS运维管理系统 - 完整用户手册

## 📋 目录

- [系统概述](#系统概述)
- [核心功能](#核心功能)
- [系统架构](#系统架构)
- [安装部署](#安装部署)
- [配置说明](#配置说明)
- [Web界面使用指南](#Web界面使用指南)
- [TCP认证系统](#TCP认证系统)
- [API接口说明](#API接口说明)
- [安全特性](#安全特性)
- [故障排除](#故障排除)
- [最佳实践](#最佳实践)

---

## 系统概述

OPS运维管理系统是一个基于Rust的分布式运维监控平台，采用客户端-服务端架构设计。系统提供实时系统监控、远程命令执行、应用版本管理、Web管理界面等企业级运维功能。

### 主要特点

- 🔐 **企业级安全**：支持Web会话认证、TCP双向认证、命令白名单验证
- 🌐 **现代化界面**：响应式Web UI，支持移动端访问
- ⚡ **高性能架构**：异步处理，支持大量并发连接
- 🛡️ **安全可靠**：多层安全防护，防止恶意命令执行
- 📱 **智能管理**：自动应用发现、版本跟踪、服务状态监控
- 🔄 **实时监控**：心跳检测、连接状态实时更新

---

## 核心功能

### 1. 系统监控
- **实时状态监控**：CPU、内存、磁盘使用情况
- **网络信息收集**：IP地址、网络连接状态
- **客户端健康检查**：心跳监测、连接状态管理
- **系统信息展示**：主机名、操作系统、硬件信息

### 2. 远程命令执行
- **安全命令执行**：基于白名单的命令验证
- **实时结果反馈**：命令执行状态和输出实时显示
- **命令历史记录**：执行历史跟踪和重复执行
- **预定义命令**：常用运维命令快速执行

### 3. 应用版本管理
- **自动应用发现**：扫描指定目录的应用部署信息
- **版本信息收集**：Git分支、提交哈希、部署时间
- **服务状态监控**：应用服务运行状态检查
- **远程应用管理**：启动、停止、重启、更新应用

### 4. Web管理界面
- **用户认证系统**：安全的会话管理，1小时自动超时
- **活动监控机制**：用户活动自动延长会话
- **响应式设计**：支持桌面和移动设备
- **多标签管理**：系统信息、应用管理、命令执行

### 5. TCP认证机制
- **HMAC-SHA256认证**：基于共享密钥的挑战-响应协议
- **防重放攻击**：时间戳验证和随机数保护
- **向后兼容**：可选启用，不影响现有部署

---

## 系统架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web Browser   │    │   ops-client    │    │   ops-client    │
│                 │    │    (Node 1)     │    │    (Node 2)     │
└─────────┬───────┘    └─────────┬───────┘    └─────────┬───────┘
          │                      │                      │
          │ HTTP/HTTPS           │ TCP                  │ TCP
          │ Port 3000            │ Port 12345          │ Port 12345
          │                      │                      │
          └──────────────────────┼──────────────────────┘
                                 │
                    ┌─────────────┴───────────┐
                    │     ops-server          │
                    │                         │
                    │  ┌─────────────────┐   │
                    │  │   Web API       │   │
                    │  │   - Auth        │   │
                    │  │   - Management  │   │
                    │  └─────────────────┘   │
                    │                         │
                    │  ┌─────────────────┐   │
                    │  │   TCP Service   │   │
                    │  │   - Client Mgmt │   │
                    │  │   - Command Exe │   │
                    │  └─────────────────┘   │
                    └─────────────────────────┘
```

### 技术栈

- **后端**：Rust + Tokio + Axum
- **前端**：原生HTML/CSS/JavaScript
- **认证**：Session-based + HMAC-SHA256
- **通信**：TCP (客户端) + HTTP (Web界面)
- **序列化**：JSON + Serde
- **日志**：Tracing + 文件轮转

---

## 安装部署

### 方式一：Docker Compose 部署（推荐）

1. **克隆项目**
```bash
git clone <repository-url>
cd ops-system
```

2. **启动服务**
```bash
# 启动完整服务（1个服务端 + 2个客户端）
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f ops-server
```

3. **访问系统**
```bash
# 打开Web界面
open http://localhost:3000
```

### 方式二：源码编译部署

1. **安装Rust环境**
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env
```

2. **编译项目**
```bash
git clone <repository-url>
cd ops-system

# 运行测试
cargo test

# 编译发布版本
cargo build --release
```

3. **部署服务端**
```bash
# 复制配置文件
cp config.example.toml config.toml

# 编辑配置
vim config.toml

# 启动服务端
cargo run --release --bin ops-server
```

4. **部署客户端**
```bash
# 在需要监控的服务器上
export OPS_SERVER_HOST=your-server-ip
export OPS_SERVER_PORT=12345
cargo run --release --bin ops-client
```

---

## 配置说明

### 服务端配置

#### 环境变量配置
```bash
# 网络配置
export OPS_TCP_BIND_ADDR=0.0.0.0      # TCP服务绑定地址
export OPS_HTTP_BIND_ADDR=0.0.0.0     # HTTP服务绑定地址
export OPS_TCP_PORT=12345              # TCP服务端口
export OPS_HTTP_PORT=3000              # HTTP服务端口

# 管理配置
export OPS_CLEANUP_INTERVAL=60         # 清理过期客户端间隔(秒)
export OPS_CLIENT_TIMEOUT=300          # 客户端超时时间(秒)
export OPS_MAX_CONNECTIONS=1000        # 最大连接数

# 安全配置
export OPS_AUTH_TOKEN=your-token-here  # API认证令牌(可选)

# TCP认证配置
export OPS_TCP_AUTH_ENABLED=true       # 启用TCP认证
export OPS_TCP_AUTH_SECRET=your-secret # TCP认证共享密钥
```

#### TOML配置文件示例
```toml
[server]
tcp_bind_addr = "0.0.0.0"
http_bind_addr = "0.0.0.0"
tcp_port = 12345
http_port = 3000
cleanup_interval_secs = 60
client_timeout_secs = 300
max_connections = 1000
auth_token = "your-secure-token"

# 脚本执行安全配置
allowed_script_dirs = [
    "/opt/ops-scripts",
    "/usr/local/bin/scripts",
    "/home/ops/scripts"
]
allowed_script_extensions = ["sh", "py", "pl", "rb"]
```

### 客户端配置

#### 环境变量配置
```bash
# 连接配置
export OPS_SERVER_HOST=127.0.0.1       # 服务端地址
export OPS_SERVER_PORT=12345            # 服务端TCP端口
export OPS_HEARTBEAT_INTERVAL=3         # 心跳间隔(秒)

# 重连配置
export OPS_RETRY_MAX_ATTEMPTS=10        # 最大重试次数
export OPS_RETRY_BASE_DELAY=2           # 基础重试延迟(秒)
export OPS_RETRY_MAX_DELAY=60           # 最大重试延迟(秒)

# 文件配置
export OPS_CLIENT_ID_FILE=/tmp/client_id.txt      # 客户端ID文件
export OPS_APPS_BASE_DIR=/tmp/apps                # 应用扫描目录
export OPS_COMMAND_LOG_FILE=/tmp/client_commands.log  # 命令日志

# 认证配置
export OPS_AUTH_TOKEN=your-token-here   # HTTP认证令牌
export OPS_TCP_AUTH_ENABLED=true        # 启用TCP认证
export OPS_TCP_AUTH_SECRET=your-secret  # TCP认证共享密钥
```

#### 命令行参数
```bash
# 基本连接配置
cargo run --bin ops-client -- --host 192.168.1.100 --port 12345

# 使用配置文件
cargo run --bin ops-client -- --config client-config.toml

# 组合配置（命令行参数优先级最高）
cargo run --bin ops-client -- --config client-config.toml --host 10.0.0.50
```

---

## Web界面使用指南

### 登录系统

1. **访问登录页面**
   - 打开浏览器访问 `http://your-server:3000`
   - 系统默认用户名：`admin`
   - 系统默认密码：`admin123`

2. **会话管理特性**
   - 登录后会话有效期：**1小时**
   - 用户活动时自动延长会话
   - 5分钟无活动显示超时警告
   - 1小时无活动自动登出
   - 页面刷新无需重新登录

### 系统信息页面

#### 系统状态概览
- **在线客户端数量**：显示当前连接的客户端总数
- **最后更新时间**：数据最后刷新时间
- **服务器运行状态**：服务器健康状态指示

#### 客户端列表
每个客户端卡片显示：
- **主机名**和**连接状态**（在线/离线）
- **客户端ID**（显示前8位）
- **CPU型号**和**内存使用情况**
- **IP地址**列表
- **最后心跳时间**和连接状态

#### 应用部署信息
- **应用名称**和**版本号**
- **部署时间**和**Git信息**
- **服务运行状态**
- 支持按客户端分组显示

### 应用管理页面

#### 筛选功能
- **客户端筛选**：按特定客户端筛选
- **应用名称筛选**：模糊搜索应用名称
- **连接状态筛选**：在线/离线客户端
- **服务状态筛选**：运行中/已停止/未知状态

#### 应用操作
- **更新应用**：指定新版本进行应用更新
- **启动服务**：启动已停止的应用服务
- **停止服务**：停止运行中的应用服务
- **服务状态查看**：实时查看服务运行状态

### 命令执行页面

#### 命令类型
1. **预定义命令**：
   - 系统信息类：`ps aux`, `whoami`, `date`, `uptime`
   - 资源监控类：`free -h`, `df -h`, `top -n 1`
   - 网络信息类：`netstat -tlnp`
   - 文件系统类：`ls -la`
   - 服务管理类：`systemctl status`

2. **自定义命令**：
   - 支持自定义输入命令
   - 自动进行安全验证
   - 危险命令会被拒绝执行

#### 命令执行流程
1. 选择目标客户端
2. 选择命令类型（预定义/自定义）
3. 选择或输入具体命令
4. 点击"执行命令"按钮
5. 实时查看执行结果

#### 执行结果显示
- **命令内容**和**执行时间**
- **退出码**：0表示成功，非0表示失败
- **标准输出**：命令的正常输出
- **错误输出**：命令的错误信息
- **执行状态**：正在执行/已完成/超时/失败

#### 命令历史
- 显示最近10条执行历史
- 支持重复执行历史命令
- 记录执行时间和目标客户端

---

## TCP认证系统

### 认证机制原理

系统采用基于HMAC-SHA256的挑战-响应认证协议：

```
1. 客户端连接服务器
2. 服务器生成随机质询 (nonce + timestamp)
3. 客户端计算响应: HMAC-SHA256(shared_secret, client_id + nonce + timestamp)
4. 服务器验证响应
5. 认证成功：正常通信 | 认证失败：断开连接
```

### 配置TCP认证

#### 服务端配置
```bash
export OPS_TCP_AUTH_ENABLED=true          # 启用TCP认证
export OPS_TCP_AUTH_SECRET=your-secret    # 共享密钥
export OPS_TCP_PORT=12346                 # TCP端口
export OPS_HTTP_PORT=3003                 # HTTP端口
```

#### 客户端配置
```bash
export OPS_TCP_AUTH_ENABLED=true          # 启用TCP认证  
export OPS_TCP_AUTH_SECRET=your-secret    # 共享密钥(与服务器相同)
export OPS_SERVER_PORT=12346              # 服务器TCP端口
```

### 安全特性

1. **防重放攻击**
   - 时间戳验证，质询30秒过期
   - 响应60秒内有效
   - 每次连接生成新的随机数

2. **防时序攻击**
   - 使用恒定时间字符串比较
   - 防止通过响应时间推测密钥

3. **密钥管理**
   - 通过环境变量配置共享密钥
   - 支持密钥轮换
   - 密钥不在代码中硬编码

### 测试TCP认证

```bash
# 服务器端 - 正确密钥
OPS_TCP_AUTH_ENABLED=true OPS_TCP_AUTH_SECRET=test-secret-123 OPS_TCP_PORT=12346 cargo run --bin ops-server

# 客户端 - 正确密钥（应该连接成功）
OPS_TCP_AUTH_ENABLED=true OPS_TCP_AUTH_SECRET=test-secret-123 OPS_SERVER_PORT=12346 cargo run --bin ops-client

# 客户端 - 错误密钥（应该被拒绝）
OPS_TCP_AUTH_ENABLED=true OPS_TCP_AUTH_SECRET=wrong-secret-456 OPS_SERVER_PORT=12346 cargo run --bin ops-client
```

---

## API接口说明

### 认证相关API

#### 登录
```bash
POST /api/login
Content-Type: application/json

{
  "username": "admin",
  "password": "admin123"
}

# 响应
{
  "success": true,
  "message": "登录成功",
  "session_id": "uuid-string"
}
```

#### 检查认证状态
```bash
GET /api/check-auth
Cookie: session_id=your-session-id

# 响应
{
  "success": true,
  "message": "已认证",
  "session_id": "uuid-string"
}
```

#### 登出
```bash
POST /api/logout
Cookie: session_id=your-session-id

# 响应
{
  "success": true,
  "message": "登出成功",
  "session_id": null
}
```

### 系统管理API

#### 获取客户端列表
```bash
GET /api/clients
Cookie: session_id=your-session-id

# 响应
{
  "clients": {
    "client-uuid": {
      "system_info": {
        "hostname": "server01",
        "cpu_model": "Intel Core i7",
        "total_memory": 16777216000,
        "used_memory": 8388608000,
        "ip_addresses": ["192.168.1.100"]
      },
      "app_info": [...],
      "last_seen": {...}
    }
  }
}
```

#### 发送命令到客户端
```bash
POST /api/send-command
Content-Type: application/json
Cookie: session_id=your-session-id

{
  "client_id": "client-uuid",
  "command": "ps aux"
}

# 响应
{
  "command_id": "command-uuid",
  "message": "命令已发送到客户端"
}
```

#### 获取命令执行结果
```bash
GET /api/command-result?command_id=command-uuid
Cookie: session_id=your-session-id

# 响应
{
  "Completed": {
    "command": "ps aux",
    "exit_code": 0,
    "output": "command output...",
    "error_output": "",
    "executed_at": {...}
  }
}
```

### 应用管理API

#### 获取应用信息
```bash
GET /api/apps
Cookie: session_id=your-session-id

# 响应
{
  "client_apps": {
    "client-uuid": {
      "client_id": "client-uuid",
      "hostname": "server01",
      "apps": [
        {
          "name": "my-app",
          "version": "v1.0.0",
          "deploy_time": "2025-08-30 10:00:00",
          "branch": "main",
          "commit": "abc123",
          "service_status": "Running"
        }
      ]
    }
  }
}
```

#### 管理应用服务
```bash
POST /api/manage-service
Content-Type: application/json
Cookie: session_id=your-session-id

{
  "client_id": "client-uuid",
  "app_name": "my-app",
  "action": "Start"  // Start, Stop, Restart, Status
}
```

#### 更新应用
```bash
POST /api/update-app
Content-Type: application/json
Cookie: session_id=your-session-id

{
  "client_id": "client-uuid",
  "app_name": "my-app",
  "version": "v1.1.0"
}
```

---

## 安全特性

### Web认证安全

1. **会话管理**
   - HTTP-only Cookie防止XSS攻击
   - Secure标志确保HTTPS传输
   - SameSite=Strict防止CSRF攻击
   - 1小时会话超时

2. **活动监控**
   - 用户活动自动延长会话
   - 5分钟无活动超时警告
   - 自动登出机制

### 命令执行安全

1. **白名单验证**
```rust
// 默认允许的安全命令
["ps", "ls", "pwd", "whoami", "date", "uptime", "df", "free", "top", "htop"]
```

2. **危险模式检测**
```rust
// 自动阻止的危险模式
["rm -rf", "shutdown", "reboot", "mkfs", "fdisk", "dd", "curl", "wget", "nc"]
```

3. **输入验证**
   - 命令长度限制
   - 特殊字符过滤
   - 注入攻击防护

### 网络通信安全

1. **TCP认证**
   - HMAC-SHA256加密验证
   - 防重放攻击保护
   - 时间戳验证

2. **连接管理**
   - 认证失败立即断开
   - 连接超时自动清理
   - 最大连接数限制

### 脚本执行安全

1. **目录限制**
   - 只允许指定目录的脚本
   - 白名单扩展名验证
   - 路径穿越防护

2. **执行权限**
   - 脚本文件权限检查
   - 用户权限限制
   - 超时保护机制

---

## 故障排除

### 常见问题及解决方案

#### 1. 客户端无法连接服务器

**症状**：客户端日志显示连接失败
```
[ERROR] Failed to create TCP session: Connection refused
```

**解决步骤**：
```bash
# 1. 检查网络连通性
telnet server_ip 12345

# 2. 检查服务器端口监听
netstat -tlnp | grep :12345

# 3. 检查防火墙设置
sudo ufw status
sudo iptables -L

# 4. 验证服务器配置
echo $OPS_TCP_PORT
echo $OPS_TCP_BIND_ADDR
```

#### 2. Web认证失败

**症状**：登录后立即被要求重新登录

**解决步骤**：
```bash
# 1. 检查会话存储
# 查看服务器日志中的会话相关信息

# 2. 清除浏览器Cookie
# 开发者工具 -> Application -> Cookies -> 删除session_id

# 3. 检查系统时间
date  # 确保客户端和服务器时间同步

# 4. 重启服务器
cargo run --bin ops-server
```

#### 3. TCP认证失败

**症状**：客户端连接时认证失败
```
[WARN] Authentication failed for client xxx
[ERROR] Client connection error: Authentication failed
```

**解决步骤**：
```bash
# 1. 确认密钥一致
echo $OPS_TCP_AUTH_SECRET  # 服务器端
echo $OPS_TCP_AUTH_SECRET  # 客户端

# 2. 检查认证配置
echo $OPS_TCP_AUTH_ENABLED

# 3. 验证时间同步
date  # 服务器和客户端时间差不能超过30秒

# 4. 查看详细日志
RUST_LOG=debug cargo run --bin ops-server
RUST_LOG=debug cargo run --bin ops-client
```

#### 4. 命令被阻止执行

**症状**：命令执行时被安全验证拒绝

**解决步骤**：
```bash
# 1. 检查命令是否在白名单中
# 查看 ops-common/src/security.rs 中的白名单

# 2. 避免危险模式
# 不要使用包含 "rm -rf", "shutdown" 等的命令

# 3. 使用预定义命令
# 在Web界面选择预定义的安全命令

# 4. 自定义白名单（开发环境）
# 修改 security.rs 中的命令白名单
```

#### 5. 应用信息收集失败

**症状**：Web界面显示"暂无客户端应用信息"

**解决步骤**：
```bash
# 1. 检查应用目录配置
echo $OPS_APPS_BASE_DIR
ls -la $OPS_APPS_BASE_DIR

# 2. 创建测试应用目录
mkdir -p /tmp/apps/test-app
echo "v1.0.0" > /tmp/apps/test-app/VERSION
echo "main" > /tmp/apps/test-app/BRANCH

# 3. 重启客户端
cargo run --bin ops-client

# 4. 检查应用扫描日志
# 查看客户端日志中的应用扫描信息
```

### 性能问题诊断

#### 1. 内存使用过高

```bash
# 监控内存使用
htop
ps aux | grep ops-server

# 检查连接数
netstat -an | grep :12345 | wc -l

# 调整配置
export OPS_MAX_CONNECTIONS=500
export OPS_CLEANUP_INTERVAL=30
```

#### 2. 响应速度慢

```bash
# 检查网络延迟
ping server_ip

# 减少心跳频率
export OPS_HEARTBEAT_INTERVAL=10

# 优化清理间隔
export OPS_CLIENT_TIMEOUT=120
```

### 日志分析

#### 服务器端日志
```bash
# 应用日志
tail -f ops-server.log.2025-08-30

# Web访问日志
tail -f web.log.2025-08-30

# 实时日志（开发模式）
RUST_LOG=debug cargo run --bin ops-server
```

#### 客户端日志
```bash
# 客户端日志
tail -f ops-client.log.2025-08-30

# 命令执行日志
tail -f /tmp/client_commands.log

# 实时日志（开发模式）
RUST_LOG=debug cargo run --bin ops-client
```

---

## 最佳实践

### 生产环境部署

#### 1. 安全配置
```bash
# 使用强密码
export OPS_TCP_AUTH_SECRET=$(openssl rand -hex 32)
export OPS_AUTH_TOKEN=$(openssl rand -hex 24)

# 限制网络访问
# 使用防火墙只允许必要的IP访问
sudo ufw allow from 192.168.1.0/24 to any port 12345

# 启用HTTPS（使用反向代理）
# nginx配置SSL证书代理到3000端口
```

#### 2. 监控配置
```bash
# 健康检查
curl http://localhost:3000/health

# 监控指标收集
# - 在线客户端数量
# - 命令执行成功率
# - 网络连接状态
# - 系统资源使用

# 日志轮转
# 配置logrotate管理日志文件
```

#### 3. 备份策略
```bash
# 定期备份配置文件
cp config.toml config.toml.backup.$(date +%Y%m%d)

# 备份客户端ID文件
cp /tmp/client_id.txt /backup/client_id.txt

# 备份重要日志
tar -czf logs_backup_$(date +%Y%m%d).tar.gz *.log*
```

### 客户端管理

#### 1. 批量部署
```bash
#!/bin/bash
# deploy_client.sh
# 批量部署客户端脚本

SERVERS="server1 server2 server3"
SERVER_HOST="ops.example.com"
SECRET="your-shared-secret"

for server in $SERVERS; do
    echo "Deploying to $server..."
    ssh $server "
        export OPS_SERVER_HOST=$SERVER_HOST
        export OPS_TCP_AUTH_ENABLED=true
        export OPS_TCP_AUTH_SECRET=$SECRET
        /opt/ops/ops-client &
    "
done
```

#### 2. 应用目录标准化
```bash
# 标准应用目录结构
/tmp/apps/
├── app1/
│   ├── VERSION      # 版本号文件
│   ├── BRANCH       # Git分支文件
│   ├── COMMIT       # Git提交哈希
│   ├── app1.sh      # 启动脚本
│   └── app1.pid     # PID文件
├── app2/
│   ├── VERSION
│   ├── BRANCH
│   ├── app2.sh
│   └── app2.pid
```

#### 3. 服务脚本模板
```bash
#!/bin/bash
# app.sh - 应用管理脚本模板

APP_NAME="myapp"
PID_FILE="/tmp/apps/$APP_NAME/$APP_NAME.pid"
LOG_FILE="/tmp/apps/$APP_NAME/$APP_NAME.log"

case "$1" in
    start)
        if [ -f $PID_FILE ] && ps -p $(cat $PID_FILE) > /dev/null; then
            echo "Service is already running"
            exit 1
        fi
        echo "Starting $APP_NAME..."
        nohup /opt/$APP_NAME/bin/$APP_NAME > $LOG_FILE 2>&1 &
        echo $! > $PID_FILE
        echo "Service started with PID $(cat $PID_FILE)"
        ;;
    stop)
        if [ -f $PID_FILE ]; then
            PID=$(cat $PID_FILE)
            kill $PID
            rm -f $PID_FILE
            echo "Service stopped"
        else
            echo "Service is not running"
        fi
        ;;
    update)
        VERSION=$2
        if [ -z "$VERSION" ]; then
            echo "Usage: $0 update <version>"
            exit 1
        fi
        echo "Updating to version $VERSION..."
        # 实现更新逻辑
        echo $VERSION > VERSION
        echo "Update completed"
        ;;
    *)
        echo "Usage: $0 {start|stop|update <version>}"
        exit 1
        ;;
esac
```

### 系统维护

#### 1. 定期维护任务
```bash
#!/bin/bash
# maintenance.sh - 系统维护脚本

# 清理过期日志
find . -name "*.log.*" -mtime +30 -delete

# 重启长时间运行的客户端
for pid in $(ps aux | grep ops-client | grep -v grep | awk '{print $2}'); do
    start_time=$(ps -p $pid -o lstart= | xargs -I {} date -d "{}" +%s)
    current_time=$(date +%s)
    runtime=$((current_time - start_time))
    
    # 运行超过7天的客户端重启
    if [ $runtime -gt 604800 ]; then
        echo "Restarting long-running client (PID: $pid)"
        kill $pid
        sleep 5
        /opt/ops/ops-client &
    fi
done
```

#### 2. 监控脚本
```bash
#!/bin/bash
# monitor.sh - 系统监控脚本

# 检查服务器健康状态
health_check() {
    response=$(curl -s http://localhost:3000/health)
    if echo "$response" | grep -q '"status":"healthy"'; then
        echo "Server health: OK"
    else
        echo "Server health: FAILED"
        # 发送告警
        echo "OPS Server health check failed" | mail -s "OPS Alert" admin@example.com
    fi
}

# 检查客户端连接数
client_check() {
    client_count=$(curl -s http://localhost:3000/api/clients | jq '.clients | length')
    echo "Connected clients: $client_count"
    
    if [ "$client_count" -lt 5 ]; then
        echo "Warning: Low client count"
        # 发送警告
    fi
}

health_check
client_check
```

### 安全加固

#### 1. 网络安全
```bash
# 防火墙配置
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow from 192.168.0.0/16 to any port 12345
sudo ufw allow from 10.0.0.0/8 to any port 3000
sudo ufw enable

# 使用nginx反向代理添加HTTPS
# /etc/nginx/sites-available/ops-system
server {
    listen 443 ssl;
    server_name ops.example.com;
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

#### 2. 系统权限
```bash
# 创建专用用户
sudo useradd -r -s /bin/false ops
sudo mkdir -p /opt/ops
sudo chown ops:ops /opt/ops

# 限制文件权限
chmod 700 /opt/ops
chmod 600 config.toml

# 使用systemd管理服务
# /etc/systemd/system/ops-server.service
[Unit]
Description=OPS Server
After=network.target

[Service]
Type=simple
User=ops
Group=ops
WorkingDirectory=/opt/ops
ExecStart=/opt/ops/ops-server
Restart=always

[Install]
WantedBy=multi-user.target
```

---

## 系统版本信息

- **当前版本**：v1.0.0
- **Rust版本要求**：1.70+
- **支持平台**：Linux, macOS, Windows
- **最后更新**：2025-08-30

---

## 技术支持

如遇到问题或需要技术支持，请：

1. 查阅本文档的故障排除章节
2. 检查项目Issues：https://github.com/your-repo/issues
3. 查看系统日志获取详细错误信息
4. 联系技术支持团队

---

**注意**：本系统仅供内部使用，请勿在生产环境中使用默认密码，确保及时更新系统并应用安全补丁。